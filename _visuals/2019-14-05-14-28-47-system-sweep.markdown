---
title:  "System Sweep"
thumbnail: "/assets/visual_previews/system-sweep"
date: 2019-05-14 14:28:47
categories: visual shader glsl demoscene
shadertoy_id: "ttX3W2" 
instagram_id: "Bxc7E5GCiwT"
twitter_id: "1128326191117680640"
layout: shadertoy
---
My _lo-fi_ take on the classic demoscene tunnel effect.   
[Procedural drone audio included, visit the ShaderToy page to hear it!](https://www.shadertoy.com/view/ttX3W2)

Spent a couple days tweaking the hell out of this, and I think it turned out pretty well. 

```glsl
/*
... System Sweep 1.0 ...

Written by @blokatt
blokatt.net

If you wish to find out what
lies at the end of this tunnel,
please refer to IEEE 754.

It's not light.

... 14/05/19 ...
*/

#define MOTION_BLUR_LENGTH 0.01 * SPEED
#define MOTION_BLUR_SAMPLES 8.0
#define MOTION_BLUR_NOISE 0.0018
#define NOISE_FILTERING 1

const float MOTION_BLUR_FALOFF = 1.0 - (1.0 / (1. + MOTION_BLUR_SAMPLES * 0.3));
const float MOTION_BLUR_LENGTH_OFFSET = MOTION_BLUR_LENGTH / MOTION_BLUR_SAMPLES;

#define CHECKERBOARD_SIZE 16.0
#define CRT_PIXEL_SIZE 6.0
#define FOG_END 0.3
#define FOG_START 1.5
#define DITHERING 0.5

#define COLOUR_A vec3(4.8, 1.8, 1.2)
#define COLOUR_B vec3(1.2, 3.8, 5.2)
#define COLOUR_C vec3(3.8, 1.8, 4.2)
#define COLOUR_D vec3(2.8, 3.8, 1.2)

#define TEXTURE_A texture(iChannel0, uv)
#define TEXTURE_B texture(iChannel1, uv)
#define TEXTURE_C texture(iChannel2, uv)

// Bayer 
vec3 dither(vec3 col, vec2 coord, int depth){        	
    float cols = float(depth);    
    float val = texture(iChannel3, coord / 8.).r;
    return (floor((col + val * (1. / cols)) * cols) / cols);
}

float rand(vec2 uv){
	return fract(sin(dot(vec2(12.9898,78.233), uv)) * 43758.5453123);
}

// Luminance 
float luma(vec3 c){
	return 0.2126 * c.r + 0.7152 * c.g + 0.0722 * c.b;
}

// Smoothly-quantised ascending funtion
float continuousSmoothstep(float x, float w){
    float v = x - w * .5;
    float b = floor(v);
	return b + smoothstep(b + 1. - w, b + 1., v);
}

// Tunnel texture
vec3 tex(vec2 uv){        
    
    float r = rand(fract(uv));    
    
    // Minimising moire in the distance
    #if (NOISE_FILTERING == 1)
    	float blur = min(0.04, fwidth(uv).x);
        uv.x += (r - .5) * blur;
        uv.y += (fract(r * 10. + .5) - .5) * blur;
    #endif
            	
    // Base texture
    float mixFactor = mod(continuousSmoothstep(uv.x / 32., .03), 3.0); 
    vec3 baseTex = mix(
                   mix(
                   mix(TEXTURE_A,
                       TEXTURE_B, clamp(0., mixFactor, 1.)),
                       TEXTURE_C, clamp(0., mixFactor - 1., 1.)), 
                       TEXTURE_A, clamp(0., mixFactor - 2., 1.)).rgb;
    
    vec3 col = baseTex * vec3(sin(TWO_PI * uv.x * 10.) * .5 + .5, sin(TWO_PI * uv.y) * .5 + .5, 1.0);
    
    // Checkerboard
    vec3 block = vec3(.4 + .6 * float(bool(floor(.5 + fract(uv.x * CHECKERBOARD_SIZE))) ^^ bool(floor(.5 + fract(uv.y * CHECKERBOARD_SIZE - SPEED * iTime * 1.5)))));
    col *= block;
    
    // Tinting
    mixFactor = mod(continuousSmoothstep(uv.x / 16. - .05, .03), 4.0); 
    vec3 tint = mix(
        		mix(
                mix(
                mix(COLOUR_A,
                   	COLOUR_B, clamp(0., mixFactor, 1.)),
                   	COLOUR_C, clamp(0., mixFactor - 1., 1.)), 
                   	COLOUR_D, clamp(0., mixFactor - 2., 1.)),
        			COLOUR_A, clamp(0., mixFactor - 3., 1.));   
    
    return (tint * ((vec3(luma(col)) - .5) * 1.12 + .5));
}

vec3 tunnel(vec2 uv, float time){    
	float travelDist = time * SPEED;    
    float sectionOsc = -sectionChange(travelDist, .15, 16.);               
    float l = length(uv) * .75;
    
    // Tiny camera wiggle
    float wiggleTime = length(travelDist + uv);
    float wiggleAngle = wiggleTime * .5;
    float wiggleOffset = sin(wiggleTime * 1.5) * .05 + sin(wiggleTime * .35 + .5) * .03;
   
    // Screen-space edge warp
    uv *= 1.5 * (1. - abs(sectionOsc) * pow(length(uv), 2.0 + 1.5 * sectionOsc));
    
    // Aspect ratio correction
    uv.x *= (iResolution.x / iResolution.y);
          
    // Space warping
    l *= 1. + sectionOsc;
    float _l2 = length(travelDist * .75 + uv);
    uv += vec2(sin(_l2), sin(.5 * _l2)) * l;
    
    // Camera wiggle    
    uv += vec2( sin(wiggleAngle) * wiggleOffset,
    			-cos(wiggleAngle) * wiggleOffset);
    
    l = length(uv);   

    // Section transition warp
   	uv *= 3. - sectionChange(travelDist + .5 / l, .15, 16.) * 2.5;    
       
    // Perspective
    float perceivedDist = 1. / length(uv);
    
    // Tunnel texture coordinates
    vec2 texCoords = vec2(1. * (perceivedDist + travelDist), (perceivedDist * .5 + travelDist) * .25 + atan((uv.x), (uv.y)) * 0.15915494309);    
    
    vec3 col = tex(texCoords);
    
    // Fog
    col *= smoothstep(FOG_END, FOG_START, inversesqrt(perceivedDist));
    
    // Clipping + brightness boost during transitions
    col = max(vec3(0), col) * (1. - sectionOsc * 5.); 
    return col;
}

// Motion blur with "temporal noise displacement" (no idea what to call this)
vec3 trail(in vec2 uv, in float t){    
	vec3 col = tunnel(uv, t + rand(fract(uv + t)) * MOTION_BLUR_NOISE);
    float factor = .5;
    for (float i = 1.; i < MOTION_BLUR_SAMPLES; i += 1.){
    	col = mix(col, tunnel(uv, t - i * MOTION_BLUR_LENGTH_OFFSET + ((rand(fract(uv + t + i * .01)) ) * MOTION_BLUR_NOISE)), 1. * factor);
        factor *= MOTION_BLUR_FALOFF;
    }
    return col;
}

// Basic CRT grid effect
vec3 crt(in vec2 uv, float t){ 
    float crtMix = sectionChange(t * SPEED + .4, .1, 16.) * .5;      

    vec2 grid = iResolution.xy / CRT_PIXEL_SIZE;    
    vec2 blockPos = uv * grid;    
    float yOff = floor(mod(blockPos.x, 2.));
    blockPos.y += .5 * yOff;    
    
    // Downsampling
    vec2 blockUV = floor(blockPos) / grid + (.5 / grid) * (1. - yOff);     
    
    vec3 texOrig = trail(uv, t); // Original colour
    vec3 texCRT = tunnel(blockUV, t) * .5; // No motion blur in CRT'd version to save time
    
    // "Phosphors"
    vec3 crtOut;
    crtOut.r = max(0., -pow((mod(blockPos.x * 6., 6.) - 1.), 2.) + 1.);
    crtOut.b = max(0., -pow((mod(blockPos.x * 6. + 2., 6.) - 1.), 2.) + 1.);
    crtOut.g = max(0., -pow((mod(blockPos.x * 6. + 4., 6.) - 1.), 2.) + 1.);    
    crtOut *= texCRT.rgb * (-pow(mod(blockPos.y * 2., 2.) - 1., 6.) + 1.) * 2.5;
    //
    
	return mix(texOrig, crtOut, min(1., crtMix * 1.5));
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{    
    float t = iTime + TIME_OFFSET;
    vec2 uv = fragCoord/iResolution.xy - .5;    
    vec3 outCol = crt(uv, t);     	
    fragColor = vec4(mix(outCol, dither(outCol, fragCoord, 4), DITHERING), 1.0);    
}
```